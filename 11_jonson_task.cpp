// 11 - Задача Джонсона. Обработки n деталей на 2 станках
#include <iostream>
#include <cstdlib>
#include<stdlib.h>
using namespace std;

int main()
{
    char fname[30]; //имя файла
    FILE* fp; //указатель файла
    printf("Input name of file: ");
    cin >> fname; //считывание имени файла
    fopen_s(&fp, fname, "r"); //открытие файла для чтения
    while ((fopen_s(&fp, fname, "r")) != NULL) { //пока функция fopen_s() выдает ошибку, просим пользователя ввести название нужного файла

        printf("It is imposimble to open file.\n");
        printf("Input name of file: ");
        cin >> fname;
    }
    int** time = (int**)malloc(1 * sizeof(int*)); //выделяем динамическую память для массива указателей (пока размера 1)
    int a; //очередной считываемы символ
    int i, j;
    j = 0;
    i = 0;
    a = getc(fp); //считываем первый символ из файла
    int a1 = 0; //очередное число
    int flag = 0; //флаг, имеющий значение 0, если произошел перенос строки, и 1 если переноса не было.
    while (a != EOF) { //пока очередной символ не EOF, продолжаем считывать символы и заполнять массив
        if (flag == 0) { //если считался элемент уже новой строки, то есть прошлым символом был \n
            time = (int**)realloc(time, (i + 1) * sizeof(int*)); //увеличиваем размер массива указателей
            time[i] = (int*)malloc(2 * sizeof(int)); //выделяем память для массива значений времени обработки для i+1 детали
            flag = 1;
        }
        if (a == 32) { //если очередной символ пробел, то закончился ввод числа a1, означающего время обработки i+1-ой детали на 1-ом станке
            time[i][j] = a1;
            j = j + 1;
            a1 = 0;

        }
        if (a == 10) { //если очередной символ \n, то закончился ввод числа a1, означающего время обработки i+1-ой детали на 2-ом станке
            time[i][j] = a1;
            i++;
            j = 0;
            a1 = 0;
            flag = 0;
        }
        if ((a >= 48) && (a <= 57)) { //если очередной символ цифра, то этот символ часть числа a1
            a1 = a1 * 10 + a - 48;
        }

        a = getc(fp); //считавание нового символа

    }
    time[i][j] = a1; //так как после последнего числа не стоит ни пробел, ни \n, то его значение не было записано в матрицу.
    int kol = i + 1; //количество деталей
    int* por = (int*)malloc(kol * sizeof(int)); //массив порядка обработки деталей
    for (i = 0; i < kol; i++) { //присваеваем каждому элементу массива por значение -1, так как оно в результате должно содержать числа от 0 до kol-1
        por[i] = -1;
    }
    int start = 0; //индекс элементов, которые добавляются с начала массива
    int end = kol - 1; //индексы элементов, которые добавляются с конца массива
    for (i = 0; i < kol; i++) { //цикл для заполнения массива pov
        int min = 0; //значение минимального элемента 
        int mini = -1; //стока минимального элемента
        int minj = -1; // столбец минимального элемента
        for (j = 0; j < kol; j++) { //поиск минимального значения в матрице
            int flag = 1;
            for (int d = 0; d < kol; d++) { //проверяем, был ли уже "удален" элемент до этого
                if (j == por[d]) flag = 0;
            }
            if (flag == 1) { //если элемент не был "удален", то сморим, если среди элементов строки минимальный
                for (int p = 0; p < 2; p++) {
                    if ((min == 0) || (time[j][p] < min)) {
                        min = time[j][p];
                        mini = j;
                        minj = p;
                    }
                }
            }
        }
        if (minj == 1) { //если минимальный элемент во второй строке, то записываем соответсующий номер детали в конец массива pov (от уже имеющейся в последовательности обработки – от конца)
            por[end] = mini;
            end--;
        }
        if (minj == 0) { //если минимальный элемент в первой строке, то записываем соответсующий номер детали в начало массива pov (от уже имеющейся в последовательности обработки – от начала)
            por[start] = mini;
            start++;
        }
    }
    printf("Order of processing parts: ");
    for (i = 0; i < kol; i++) { //выводим последовательность обработки деталей
        printf("%d ", por[i] + 1);
    }
    printf("\nGantt chart: "); //выводим график Ганта
    printf("\n1 machine: ");
    for (i = 0; i < kol; i++) { //первый станок
        if (por[i] != -1) {
            for (j = 0; j < time[por[i]][0]; j++) {
                printf("%2d ", por[i] + 1);
            }
        }
    }
    printf("\n2 machine: ");
    int n = 0;
    int n1 = 0;
    for (i = 0; i < kol; i++) { //второй станок
        n1 = n1 + time[por[i]][0];
        while (n < n1) { //если обработка на первом станке еще не закончилась, выводим пробелы, обозначающие пропуск
            printf("   ");
            n++;
        }
        for (j = 0; j < time[por[i]][1]; j++) {
            printf("%2d ", por[i] + 1);
            n++;
        }
    }
    printf("\nTime of processing = %d", n); //выводим сумарное время
    fclose(fp); //закрытие файла
    free(por); //освобождение памяти 
    for (i = 0; i < kol; i++) { //освобождение памяти
        free(time[i]);
    }
    free(time); //освобождение памяти
}
